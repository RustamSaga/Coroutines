# Channel

Канал используется, как средство передачи данных между корутинами. Т.е. он является **ячейкой**,
куда одна корутина может поместить данные, а другая корутина - взять их оттуда.

Простой пример:

```kotlin
val channel = Channel<Int>()

launch {
    //...
    channel.send(4)
    //...
}

launch {
    //...
    val res = channel.receive()
    //...
}
```

**Канал - потокобезопасен и нам не надо самим возиться с блокировками и синхронностью.**

### send & receive

Если первая корутина пытается отправить данные методом `send`, но вторая корутина еще не вызвала
`receive`, то метод send приостановит первую корутину и будет ждать. Аналогично наоборот. Если
вторая корутина уже вызвала `receive`, чтобы получить данные, но первая корутина еще не отправила
их, то метод receive приостановит вторую корутину.

В плане потоков методы `send` и `receive` ведут себя так же, как и обычные suspend функции. Они
приостанавливают корутину, если им приходится ждать отправления или получения данных. Когда корутина
возобновляется, она может продолжить свое выполнение в другом потоке. Но в любом случае это будет
поток из диспетчера корутины.

## Передача нескольких элементов

Через один канал можно отправлять данные сколько угодно раз.

**Каждый метод `send` ждет вызова `receive`**. Если будет, например, 5 вызовов `send` и только 3
`receive`, то первая корутина остановится на 4-м вызове `send` и больше **не продолжится**.

```kotlin
launch {
// ...
    channel.send(5)
// ...
    channel.send(6)
// ...
    channel.send(7)
// ...
    channel.send(8)
// ...
    channel.send(9)
}

launch {
// ...
    var i = channel.receive()
// ...
    i = channel.receive()
// ...
    i = channel.receive()
}

//Значение 8 не будет отправлено, т.к. получать его будет некому.
```

Аналогично наоборот

```kotlin
launch {
// ...
    channel.send(5)
// ...
    channel.send(6)
// ...
    channel.send(7)
}

launch {
// ...
    var i = channel.receive()
// ...
    i = channel.receive()
// ...
    i = channel.receive()
    // ...
    i = channel.receive()
    // ...
    i = channel.receive()
    // ...
    i = channel.receive()
}

// Четвертый receive не дождется отправки данных и приостановит вторую корутину навсегда..
```

## close

Метод `close` - это явный сигнал о том, что данные больше передаваться не будут.

```kotlin
launch {
// ...
    channel.send(5)
// ...
    channel.send(6)
// ...
    channel.send(7)
    channel.close()
}
```

В этом случае в канал помещается специальное служебное значение `Closed`. Если получатель попробует
получить данные после закрытия канала (или уже ждет данные в момент закрытия), то метод `receive`
получит этот `Closed` и выбросит исключение `ClosedReceiveChannelException`.

Вместо `receive` нужно использовать цикл for (чтобы самим не возиться с исключениями)

```kotlin
launch {

    for (element in channel) {
        // ...
    }

}
```

Также, на стороне получателя мы можем использовать метод `chanel.isClosedForReceive`, чтобы понять,
что канал закрыт и данных в нем не осталось

## capacity

По умолчанию канал может хранить в себе только одно значение, пока получатель не заберет его. Это
поведение можно поменять, используя параметр `capacity` при создании канала.

```kotlin
val channel = Channel<Int>(2)

launch {
    repeat(7) {
        delay(300)
        log("send $it")
        channel.send(it)
    }
    log("close")
    channel.close()
}

launch {
    for (element in channel) {
        log("received $element")
        delay(1000)
    }
}
```

log

```
14:32:32.238 send 0
14:32:32.239 received 0
14:32:32.553 send 1
14:32:32.854 send 2
14:32:33.156 send 3
14:32:33.247 received 1
14:32:33.549 send 4
14:32:34.248 received 2
14:32:34.550 send 5
14:32:35.250 received 3
14:32:35.564 send 6
14:32:36.253 received 4
14:32:36.253 close
14:32:37.264 received 5
14:32:38.266 received 6
```

`send` уже не дожидается `receive` - т.к в `channel` еще есть место. Как только мест не остается,
корутина приостанавливается.

Обратите внимание, что даже после закрытия канала (close), получатель сможет получить все данные из
буфера.

### Conflated

Этот режим хранит только один элемент, однако `send` не дожидаясь `receive` перезапишит данные.

```kotlin
val channel = Channel<Int>(Channel.Factory.CONFLATED)

launch {
    repeat(7) {
        delay(300)
        log("send $it")
        channel.send(it)
    }
    log("close")
    channel.close()
}

launch {
    for (element in channel) {
        log("received $element")
        delay(1000)
    }
}
```

LOG

```
14:37:35.657 send 0
14:37:35.658 received 0
14:37:35.958 send 1
14:37:36.261 send 2
14:37:36.562 send 3
14:37:36.664 received 3
14:37:36.865 send 4
14:37:37.165 send 5
14:37:37.468 send 6
14:37:37.468 close
14:37:37.673 received 6
```

### Unlimited

Размер буфера в таком канале ограничен только количеством доступной памяти.

```kotlin
val channel = Channel<Int>(Channel.Factory.UNLIMITED)
```

### Buffered

Канал с размером буфера = 64 по умолчанию. Это значение можно поменять в JVM.

```kotlin
val channel = Channel<Int>(Channel.Factory.BUFFERED)
```

## cancel

Это то же самое, что и `close()`, только с очисткой буфера.

при попытке вызвать receive для отмененного канала будет выброшено
исключение `CancellationException`, а не `ClosedReceiveChannelException`

и цикл for также выбросит исключение `CancellationException`

## Получатель закрывает канал

Разумеется, отменить/закрыть канал может и корутина получатель. При этом в корутине отправителе
метод `send` выбросит, соответственно, исключение `CancellationException` (что приведет к отмене
корутины) / `ClosedSendChannelException` (что приведет к крэшу, если исключение никак не
обрабатывается).

Отправитель может использовать метод `channel.isClosedForSend()`, чтобы определить, можно ли
отправлять данные в канал.

## Отмена корутины

Если отменить корутину-отправителя, тогда отправка будет отменена а корутина завершится.
Однако `channel` продолжит работать. Т.е. корутина-получатель ничего не узнает и продолжит ждать.

Чтобы это исправить, как вариант, можно в корутине-отправителе явно попросить `job` завершать работу
канала при завершении работы корутины.

```kotlin
launch {
    coroutineContext[Job]?.invokeOnCompletion {
        channel.close()
    }
// ...
}
```

`invokeOnCompletion` вызовется как при нормальном завершении корутины, так и при отмене или ошибке.

Аналогично со стороны получателя. Если отменить корутину получателя, то получение будет отменено и
корутина завершится. А отправитель (если он еще работает) будет продолжать пытаться отправить
данные.

## Несколько отправителей или получателей

Может быть так, что отправителей больше одного и наоборот.

```kotlin
val channel = Channel<Int>()

launch {
// ..
    channel.send(1)
// ..
    channel.send(2)
// ..
}

launch {
// ..
    channel.send(11)
// ..
    channel.send(12)
// ..
}

launch {
    for (element in channel) {
// ...
    }
}
```

правда, возникает вопрос - кто будет закрывать канал?

Как вариант, можно все корутины отправители поместить в один отдельный родительский `launch` и в нем
использовать `invokeOnCompletion`. Он будет выполнен, только когда выполнится родительский `launch`
и
все корутины внутри него. В нем вполне можно закрыть канал, чтобы уведомить получателя.

```kotlin
val channel = Channel<Int>()

launch {
    coroutineContext[Job]?.invokeOnCompletion {
        channel.close()
    }
    launch {
        // channel.send(...)
    }
    launch {
        // channel.send(...)
    }
}
launch {
    for (element in channel) {
        // ...
    }
    // ...
}
```

## produce

это

```kotlin
val channel = Channel<Int>()

launch {
// ...
    channel.send(5)
// ...
    channel.send(6)
// ...
    channel.send(7)
// ...
    channel.close()
}
```

можно переписать в это:

```kotlin
val channel = produce<Int> {
    //...
    send(3)
    //... 
    send(2)
    //...
    send(8)
}
```

Билдер produce создает и запускает отдельную корутину. Также создает канал

Билдер возвращает созданный канал, как ReceiveChannel.

```kotlin
interface Channel<E> : SendChannel<E>, ReceiveChannel<E>
```

Т.е. канал, который мы получаем от билдера `produce`, предназначен только для получения данных, не
для отправки. Предполагается, что отправлять в него данные будет только блок кода билдера `produce`.

У этого симбиоза корутины и канала есть две важные особенности:

1) канал будет автоматически закрыт по выполнению блока кода. Нам не надо самим вызывать `close()`.
2) если отменить корутину, в который был вызван `produce`, то канал также отменится.
   Соответственно, если где-то там наверху отменен `scope` или одна из корутин выше по иерархии, то
   отмена доберется и до этого канала.

## consume

Есть еще один вариант получения данных из канала.

```kotlin
channel.consumeEach { element ->
    // ...
}
```

Под капотом тут просто `try-catch` обертка над for циклом. Если эта обертка поймает ошибку (в нашем
коде обработки получаемых данных), то она отменит канал.

## BroadcastChannel

_Является устаревшим. В качестве замены используйте SharedFlow._

Все данные, отправляемые в обычный канал будут равномерно распределены между получателями.

Чтобы все получатели смогли получить все данные, необходимо использовать `BroadcastChannel`.

```kotlin
val broadcastChannel = BroadcastChannel<Int>(1)
```

В конструкторе нужно указать `capacity`.

* Значение по умолчанию 0 здесь уже не подойдет.
* Нельзя использовать безлимит - `UNLIMITED`.

`BroadcastChannel` наследует интерфейс `SendChannel`. Поэтому у него есть метод `send` для отправки
данных.

```kotlin
broadcastChannel.send(5)
```

А каждый, кто собирается получать данные, может создать себе отдельный `ReceiveChannel` методом
`openSubscription`.

```kotlin
val channel = broadcastChannel.openSubscription()
```

Особенности:

* Когда мы создаем себе канал методом `openSubscription`, мы уже не получим в этот канал данные,
  отправленные ранее. Даже если они все еще лежат в буфере.
* При отправке данных в обычный канал, мы знаем, что отправка будет ждать, пока получатель не
  заберет данные или пока не освободится место в буфере. Отправка данных в `BroadcastChannel`
  работает аналогично. Она ждет, пока во всех созданных методом `openSubscription` каналах
  получатели не заберут данные. Только, когда данные ушли всем, тогда можно отправлять следующие
  данные

## trySend
Кроме suspend метода `send`, канал дает нам возможность попытаться отправить данные обычным (не
suspend) методом. В этом случае если получатель не готов к приему, то данные просто не уйдут.

Раньше для этого использовался метод `offer`, но сейчас он объявлен устаревшим. Вместо него
используем `trySend`.

В качестве результата он вернет `ChannelResult`, из которого можно понять, удалось ли отправить
данные. 


