# **Обработка исключений. Async, suspend.**

### async

все тоже самое как и с `launch`, с одним отличием - в методе `await` для получения результата

```kotlin
scope.launch {

    val deferred = async {
        // exception
    }
    // ...

    val result = deferred.await()

    //...
}
```

`launch` запускает `async` корутину и методом `await` подписывается на ожидание результата. Когда
в `async`
произойдет исключение, оно будет поймано и отправлено в родительский `launch` и далее вверх. Т.е.
родительский `launch` будет отменен. А метод `await` вместо результата выбросит то самое исключение,
которое произошло в `async`.

`try-catch` сможет повлиять на выполнение кода `launch` до конца.

* **Если мы не ловим исключение** из `await` в `try-catch`, то `launch` сам его ловит и завершает
  свою работу.
  Он снова отправит ошибку наверх, но это уже ничего не изменит. А код, который в `launch` был
  расположен после вызова `await`, не будет выполнен.

* **Если же мы ловим исключение** - то `launch` продолжает выполнять свой код, который находится
  после `await`. Даже если `launch` отменен.

Таким образом, в примере с родительским `launch` оборачивать `await` в `try-catch` имеет смысл, если
вам
необходимо, чтобы код после `await` был выполнен.

### SupervisorJob

Если мы использовали тат кастыль - parentJob > supervisorJob > childJob (из n14)

```kotlin
scope.launch { // parent coroutine

    launch(SupervisorJob(coroutineContext[Job])) { // child coroutine

    }
}
```

Ошибка не пройдет наверх по иерархии, `supervisorJob` ее туда не пропустит. Тогда `async` нужно
будет обработать ошибку самостоятельно, но `async` не может этого сделать (в отличие от `launch`).
Она сохраняет это исключение внутри себя, чтобы выбросить его, когда вызовут ее метод `await`.

`launch`, вызывает метод `await`. До вызова `await` у него все было хорошо. Он не был отменен
дочерним `async` (в котором произошла ошибка), потому что `supervisorJob` не позволил этого сделать.
Т.е. корутина `launch` работает в штатном режиме и ей есть что терять. И если не обернуть `await`
в `try-catch`, то получится так, что внутри `launch` произойдет исключение. Оно отменит `launch` и
пойдет дальше наверх по корутинам все отменять.

Поэтому в случае, когда мы от `async` отгораживаемся c помощью `SupervisorJob`, ловить ошибку
из `await` надо обязательно.

### Suspend - обработка ошибки внутри suspend fun

1. resumeWithException

   Внутри `suspend` есть `continuation` у которого есть метод `resume`, кроме этого метода есть
   метод
   `resumeWithException`. (n3_suspend_fun)

   При получение ошибки вызывается метод `resumeWithException` (если мы его обернули). Для корутины
   это будет равносильно тому, что вызов `suspend` функции выбросил исключение.

   Если вызов `suspend` функции был обернут в `try-catch`, то ошибка никуда дальше не пойдет. Если
   `try-catch` не было, то корутина прерывается и ошибка идет наверх по иерархии корутин.

2. Синхронная часть

   из урока n3_suspend_fun - было понятно, что если результат работы готов сразу, то его можно
   вернуть не запуская фоновую работу.

```kotlin
suspend fun download(url: String): File {
    val networkService = NetworkService()

    // suspendCoroutine - для старых легаси где колбеки
    return suspendCoroutine { continuation ->

        val file = getFileFromCache(url)

        if (file != null) {
            continuation.resume(file) // не запускает фоновую если результат готов
        } else {
            networkService.download(url, object : NetworkService.Callback {
                override fun onSuccess(result: File) {
                    continuation.resume(result)
                }

                override fun onFailure(error: Exception) {
                    continuation.resumeWithException(error)
                }

            })
        }
    }
}
```

Если в этом `val file = getFileFromCache(url)` возникло исключение, то это будет равносильно тому,
что `suspend` функция в корутине выбросила исключение.

3. Асинхронная часть

Если же ошибка произойдет в асинхронной части и не будет там поймана в `try-catch`, то приложение
свалится с крэшем. И даже если обернуть `suspend` функцию в `try-catch` или использовать
`CoroutineExceptionHandler`, **это не поможет**.

Потому что это **был отдельный поток**. И выполнялась там **не корутина**, которая автоматически ловит все
ошибки своего кода, а обычный код. А непойманное **исключение в обычном коде приводит к крэшу.**

