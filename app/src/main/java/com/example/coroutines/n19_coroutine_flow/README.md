# Flow

`Flow` - это упакованный в объект фрагмент кода, который производит какой-то последовательный набор
элементов (данных).

`Flow` предназначен для асинхронной обработки потока данных, который выполняется последовательно. Мы
можем выполнять различные операции с последовательными данными: преобразовывать, фильтровать,
сопоставлять.

У `flow` есть

* **отправитель** - который этот код создал и готов предоставить его в виде `Flow` обертки.
* **получатель** - который возьмет этот `Flow`, запустит его и предоставит ему специальный колбэк,
  куда `Flow` будет складывать данные, который он производит.

При создании она ничего не делает. Но как только мы ее запустим, она начнет работу и будет постить
результаты в колбэк, который мы ей предоставим.

# Имитация flow

```kotlin
fun searchFlight(criteria: Criteria): ((Flight) -> Unit) -> Unit {
    return { onFind ->
        for (airCarrier in getAirCarriers()) {
            val flight = airCarrier.searchFlight(criteria)
            onFind(flight)
        }
    }
}
```

Мы передаем ей на вход критерии поиска, и она возвращает объект-функцию, которая при ее запуске
будет выполнять поиск по этим критерям. Т.е. критерии поиска уже зашиты в ней. Осталось только
запустить ее, когда понадобится.

На стороне клиента:

```kotlin
val search = searchFlight(criteria)

/// ...

search.invoke { flight ->
    showFlight(flight)
}
```

Вместо обычного результата своей работы, она возвращает нам объект. Этот объект мы можем запустить,
как функцию, и получать в колбэк результаты его работы в виде последовательности данных. -
аналог `Flow`

А теперь тоже самое, но через `flow`

```kotlin
fun searchFlight(criteria: Criteria): Flow<Flight> {
    return flow {
        for (airCarrier in getAirCarriers()) {
            val flight = airCarrier.searchFlight(criteria)
            emit(flight)
        }
    }
}
```

И на стороне клиента:

```kotlin
val searchFlow = searchFlight(criteria)

/// ...

scope.launch {
    searchFlow.collect { flight ->
        showFlight(flight)
    }
}
```

# Flow под копотом

В качестве примера:

```kotlin
val flow = flow {
    // flow block
    for (i in 1..10) {
        delay(100)
        emit(i)
    }
}
```

Код, что выше, не запускается сразу, а только создается.

Чтобы запустить:

```kotlin
flow.collect { i ->
    // collect block
    log(i)
}
```

Этапы:

1. Создается объект `Flow`, он хранит в себе блок `flow`, в котором содержится код по генерации
   данных и отправке их в метод `emit`.

```kotlin
val flow = flow {
// flow block
    for (i in 1..10) {
        delay(100)
        emit(i)
    }
}
```

2. Чтобы запустить работу и начать получать данные, мы вызываем метод `collect` и на вход
   этому методу передаем блок `collect`, в этом блоке мы получаем объекты создаваемые в блоке
   `flow`. Теперь у `Flow` есть два блока кода: `flow` и `collect`. Их можно считать отправителем и
   получателем. Осталось стартовать работу отправителя, а результаты передавать получателю.

```kotlin
flow.collect { i ->
    // collect block
    log(i)
}
```

3. Когда мы запускаем метод `collect`, `Flow` берет свой блок `flow` и запускает его, тем самым
   стартуя работу. А в методе `emit` он включает перенаправление в блок `collect`.

```kotlin
// под копотом
fun collect(...) {
    // flow block
    for (i in 1..10) {
        delay(100)
        // collect block
        log(i)
    }
}
```

`flow block` генерирует данные и отправляет их в `emit(...)`, затем `emit(...)` отправляет эти
данные в `collect block`.

# Coroutine flow

1. метод `.collect()` запускает `flow block`, чтобы начать работу
   метод `collect` помечен, как `suspend` и может быть вызван только в корутине (или
   другой `suspend` функции).

2. `flow block` запускает `collect block` (через `emit`), чтобы отправлять данные.

Метод `collect` является `suspend`. Внутри себя он запускает и `flow block` и `collect block`.
Поэтому вся работа по отправке и получению данных будет выполнена в корутине, в которой мы вызываем
метод `collect()`.

А метод `flow()` может быть вызван где угодно. Он только создает объект `Flow` и помещает в него
блок `flow`. Но он ничего не запускает.

# Отличие flow от channel

И с `channel` и с `Flow` можно отправлять/получать данные.

Но, `channel` - это просто потокобезопасный инструмент для передачи данных между корутинами. Он не
создает ничего. Только передает. Т.е. **должны существовать отправитель и получатель**. Они работают
в своих корутинах независимо друг от друга, используя канал для обмена данными.

А `Flow` - это генератор данных. В этом случае нет явного отправителя. Вместо него есть создатель.
Он создает `Flow` и дает его получателю. Получатель запускает `Flow` в своей корутине и, можно
сказать,
сам же становится отправителем.

# Расширенная suspend функция

И вызываем ее в корутине

```kotlin
launch {
    searchFlight(criteria).collect { flight ->
        showFlight(flight)
    }
}
```

В этом случае `suspend` функцией является метод `collect()`. Но он не возвращает нам одно
единственное значение. Он позволяет нам получить последовательность данных. И он приостанавливает
корутину на время следующего элемента. А когда последовательность закончится, корутина пойдет
дальше.

Т.е. `Flow` расширяет возможности `suspend` функций, позволяя нам получать последовательность данных
в `suspend` режиме.

Иначе в обычной `suspend fun` без `flow` - она даст результат только тогда, когда получит все
данные.

## Flow о котором мы говорили это - cold flow.

Т.е каждый вызов `collect` будет приводить к тому, что снова будет запускаться блок `flow` и
генерировать элементы