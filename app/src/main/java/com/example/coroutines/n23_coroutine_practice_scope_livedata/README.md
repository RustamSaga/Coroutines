# Практика. Scope, LiveData.

## Scopes - viewModelScope, lifecycleScope, MainScope.

### viewModelScope

В любом месте `ViewModel` мы можем использовать `viewModelScope`, чтобы запустить новую корутину:

```kotlin

class MainViewModel : ViewModel() {
    viewModelScope.launch
    {
        //...
    }
}
```

`viewModelScope` изнутри:

```kotlin
CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)
```

`CloseableCoroutineScope` - это просто обертка над `CoroutineScope`. Она обеспечивает отмену скопа,
когда модель завершает свою работу.

`SupervisorJob` - корутины независимы друг от друга, при возникновении ошибки, остальные корутины
продолжат работу (смотри n13)

`Dispatchers.Main.immediate` - Диспетчер не откладывает выполнение кода а выполняется сразу как
пришла его очередь (если вызов был из main потока). Диспетчер понимает, что можно выполнить
код здесь и сейчас, т.к. мы уже в Main потоке.

Это поведение немного похоже на поведение диспетчера `Unconfined`.

**Почему Main?** - Чтобы была возможность вместо колбэков или конструкций RxJava использовать
suspend
функции. Они могут быть запущены только в корутинах. Именно suspend функции и будут тем, кто пойдет
выполнять свою работу в фоновый поток, не блокируя при этом Main поток, а лишь приостанавливая код
корутины. А когда результат будет готов, выполнение корутины в Main потоке возобновится.

### lifecycleScope

```kotlin
LifecycleOwner.lifecycleScope
```

Таким `LifecycleOwner` объектом может быть `Activity`, `фрагмент` или `View`-составляющая
фрагмента (`viewLifecycleOwner`).

Также как у `viewModelScope`

```kotlin
SupervisorJob() + Dispatchers.Main.immediate
```

Т.е. это независимые друг от друга корутины и Main поток.

Пример:

```kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        lifecycleScope.launch {
            while (true) {
                delay(1000)
                log("work")
            }
        }

    }

}
```

`LifecycleScope` вызывается в любом месте Activity (или фрагмента). При закрытии экрана `scope`
будет отменен. При повороте он также будет отменен, но будет создан новый в новом Activity, и новая
корутина будет запущена.

У `lifecycleScope` есть билдеры `launchWhenCreated`, `launchWhenStarted` и `launchWhenResumed` для
вызова корутин с отслеживанием текущего состояния `LifeCycle`.

### MainScope

```kotlin
val scope = MainScope()
```

под капотом

```kotlin
ContextScope(SupervisorJob() + Dispatchers.Main)
```

В отличие от `viewModelScope`, `lifecycleScope` - ни к чему не привязан.

А `MainScope` - сам по себе, и может быть создан и использован где угодно. Но нам надо самим следить
за тем, когда его отменять. Т.е. если у нас есть какой-то свой объект с жизненным циклом и ему надо
запускать корутины, то мы можем при его создании создавать ему `MainScope`, а при его уничтожении -
отменять этот scope.

### Либо свой Scope - примеры n7

## Работа с View

Весь код корутины выполняется в `Main` потоке (для `View`). Кроме suspend функций. Они свою работу
вынесут в фоновый поток, и как только все сделают, вернутся в `Main`. При этом никакой
блокировки `Main` потока не происходит.

### Комбинация корутины и LiveData.

пример:

```kotlin
val liveData = liveData<String> {
    while (true) {
        delay(1000)
        emit("work")
    }
}
```

Билдер `liveData` создает корутину и возвращает `LiveData`. Внутри корутины мы используем
метод `emit`, чтобы постить данные в получившуюся `LiveData`.

Время жизни создаваемой корутины зависит от наличия подписчика создаваемой `LiveData`. Т.е. под
капотом создается `scope`, который завязан на состояние активности `LiveData`. Корутина **стартует**
не в момент создания, а **когда кто-либо подписывается** на `LiveData`.

Если подписчик решает отписаться когда корутина **еще работает**, то корутине дается таймаут **5
секунд** на завершение своей работы. Если она не успеет закончить, то будет отменена. И когда кто-то
снова подпишется на `LiveData`, корутина будет перезапущена.

Если корутина нормально (без отмены по таймауту) заканчивает свою работу, то она уже не будет
перезапущена при следующей подписке на `LiveData`.

Т.е. можно сказать, что эта корутина - одноразовая. Успешно она выполнится только один раз. И у нас
нет возможности ее перезапустить вручную чтобы, например, получить свежие данные. Надо будет
создавать новую пару `LiveData + корутина`.

Под капотом `scope` все тот же набор `SupervisorJob` и `Dispatchers.Main.immediate`. Но в билдер
можно передать и свой контекст. Например, чтобы сменить диспетчера.

***

* **Закрытие экрана**. При этом событии подписчик отпишется от `LiveData`. Корутина еще 5 секунд
  работает, а потом отменяется.

* **Поворот экрана**. Старый подписчик отписывается от `LiveData`, но тут же подписывается новый в
  создаваемом `Activity`. Состояние без подписчика явно будет длиться меньше чем 5 секунд, поэтому
  корутина не будет отменена, а продолжит свою работу с новым подписчиком `LiveData`.

* **Сворачивание приложение больше, чем на 5 секунд.** Подписчик отписывается от `LiveData`. Через 5
  секунд корутина отменяется. Когда приложение снова будет открыто, возобновится и подписка. И т.к.
  корутина была отменена по таймауту, то она будет перезапущена. При этом у нас есть возможность
  внутри корутины узнать, какое последнее значение было отправлено (`emit`) перед таймаутом. Для
  этого используем `latestValue`.